{% extends "base.html" %}
{% load static %}

{% block title %}Register Pattern - Level Two Authentication{% endblock %}

{% block content %}
<div class="container mt-5">
    <div class="row justify-content-center">
        <div class="col-md-10">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h2 class="text-center">Register - Level Two</h2>
                </div>
                <div class="card-body">
                    <p class="text-center text-muted mb-4">Sequence-Based Pattern Authentication (Step 2 of 3)</p>
                    
                    <div class="progress mb-4">
                        <div class="progress-bar" role="progressbar" style="width: 66%;" aria-valuenow="66" aria-valuemin="0" aria-valuemax="100">Step 2 of 3</div>
                    </div>
                    
                    <div class="pattern-authentication">
                        <!-- Instructions -->
                        <div class="instructions mb-4 alert alert-info">
                            <p><strong>Enhanced Pattern Authentication:</strong></p>
                            <p>Create a unique sequence-based pattern that only you know:</p>
                            <ol>
                                <li>Upload an image and click "Create Grid"</li>
                                <li>The image will be split into 9 numbered pieces (1-9)</li>
                                <li>Create your custom pattern by dragging pieces to positions in a specific sequence</li>
                                <li>For example: Block 3 to Position 3, then Block 1 to Position 1, then Block 6 to Position 6</li>
                                <li><strong>Remember your sequence!</strong> During login, pieces will be randomly shuffled and you'll need to recreate the same pattern logic</li>
                            </ol>
                        </div>

                        <form id="patternForm" enctype="multipart/form-data">
                            {% csrf_token %}
                            <!-- Image Upload Section -->
                            <div class="upload-section mb-4">
                                <input type="file" id="imageUpload" name="image" accept="image/*" class="form-control mb-2">
                                <button id="splitImage" class="btn btn-primary" disabled>Create Grid</button>
                            </div>

                            <!-- Pattern Progress -->
                            <div id="pattern-progress" class="alert alert-secondary mb-3" style="display: none;">
                                Pieces placed: <span id="pieces-count">0</span>/9
                            </div>

                            <!-- Pattern Sequence Display -->
                            <div id="pattern-sequence" class="alert alert-info mb-3" style="display: none;">
                                Your sequence: <span id="sequence-display"></span>
                            </div>

                            <!-- Grid Container -->
                            <div class="grid-container" style="display: none;">
                                <!-- Source Grid (Left) -->
                                <div class="grid source-grid" id="sourceGrid"></div>

                                <!-- Target Grid (Right) -->
                                <div class="grid target-grid" id="targetGrid"></div>
                            </div>

                            <div id="error-message" class="alert alert-danger mt-3" style="display: none;"></div>
                            <button type="submit" id="submitPattern" class="btn btn-success mt-3" style="display: none;">Save Pattern</button>
                        </form>
                    </div>
                </div>
                <div class="card-footer text-center">
                    <a href="{% url 'register_cancel' %}" class="btn btn-outline-secondary btn-sm">Cancel Registration</a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<style>
    .grid-container {
        display: none;
        justify-content: space-around;
        align-items: start;
        margin: 40px 0;
        gap: 50px;
    }
    
    .source-grid, .target-grid {
        display: grid;
        grid-template-columns: repeat(3, 100px);
        gap: 2px;
        background: #ccc;
        padding: 2px;
    }
    
    .grid-item {
        width: 100px;
        height: 100px;
        position: relative;
        overflow: hidden;
        background: white;
        border: 1px solid #ccc;
        cursor: move;
    }
    
    .grid-item img {
        position: absolute;
        pointer-events: none;
    }
    
    .grid-item.dragging {
        opacity: 0.5;
    }
    
    .grid-cell {
        width: 100px;
        height: 100px;
        border: 2px dashed #666;
        background: white;
        position: relative;
    }
    
    .grid-cell.dragover {
        background: #f0f0f0;
        border-style: solid;
    }
    
    .grid-cell.filled {
        border: 2px solid #28a745;
    }
    
    .grid-item::before {
        content: attr(data-position);
        position: absolute;
        top: 5px;
        left: 5px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 2px 6px;
        border-radius: 3px;
        z-index: 1;
    }

    .grid-cell::before {
        content: attr(data-index);
        position: absolute;
        top: 5px;
        left: 5px;
        background: rgba(0,0,0,0.3);
        color: white;
        padding: 2px 6px;
        border-radius: 3px;
    }
    
    .sequence-number {
        display: inline-block;
        width: 24px;
        height: 24px;
        line-height: 24px;
        text-align: center;
        background-color: #007bff;
        color: white;
        border-radius: 50%;
        margin: 0 3px;
    }
</style>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const imageUpload = document.getElementById('imageUpload');
        const splitButton = document.getElementById('splitImage');
        const sourceGrid = document.getElementById('sourceGrid');
        const targetGrid = document.getElementById('targetGrid');
        const gridContainer = document.querySelector('.grid-container');
        const submitButton = document.getElementById('submitPattern');
        const patternSequenceDiv = document.getElementById('pattern-sequence');
        const sequenceDisplay = document.getElementById('sequence-display');
        const patternForm = document.getElementById('patternForm');
        
        // Track the sequence of placements (which block was placed where)
        let placementSequence = [];
        
        imageUpload.addEventListener('change', function() {
            splitButton.disabled = !this.files.length;
        });
    
        function updatePiecesCount() {
            const filledCells = document.querySelectorAll('.target-grid .grid-cell[data-filled]');
            const progressSpan = document.getElementById('pieces-count');
            progressSpan.textContent = filledCells.length;
            
            // Show/hide submit button based on all pieces being placed
            submitButton.style.display = filledCells.length === 9 ? 'block' : 'none';
        }
        
        function updateSequenceDisplay() {
            if (placementSequence.length > 0) {
                patternSequenceDiv.style.display = 'block';
                sequenceDisplay.innerHTML = placementSequence.map(mapping => 
                    `<span class="sequence-number">${mapping.blockId}</span> â†’ <span class="position-number">${mapping.position}</span>`).join(', ');
            }
        }

        function logPattern() {
            const filledCells = document.querySelectorAll('.target-grid .grid-cell[data-filled]');
            
            // Create detailed pattern information including the sequence
            const pattern = {
                // Store each placement with block ID and target position
                placements: Array.from(filledCells).map(cell => ({
                    blockId: parseInt(cell.dataset.filled),     // The piece number
                    position: parseInt(cell.dataset.index),     // Where it was placed
                    placementTime: cell.dataset.placementTime
                })),
                // Store the sequence of blockIds in the order they were placed
                sequence: placementSequence.map(item => ({
                    blockId: item.blockId,
                    position: item.position
                }))
            };
            
            console.log('Pattern sequence for registration:', pattern.sequence);
            return pattern;
        }
        
        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('dragover');
    
            const blockId = e.dataTransfer.getData('text/plain'); // The piece number
            const targetPosition = this.dataset.index;            // The cell position
            
            // UPDATED: Force placing each block in its matching position
            if (blockId !== targetPosition) {
                showError(`Block ${blockId} must be placed in position ${blockId}`);
                return;
            }
            
            // If cell already has a piece, don't allow drop
            if (this.hasChildNodes()) {
                return;
            }
    
            const draggedItem = document.querySelector(`.grid-item[data-position="${blockId}"]`);
    
            if (!this.hasChildNodes()) {
                const clone = draggedItem.cloneNode(true);
                clone.classList.remove('dragging');
                this.appendChild(clone);
                
                // Mark the cell as filled and store placement data
                this.dataset.filled = blockId;
                this.dataset.placementTime = Date.now().toString();
                this.classList.add('filled');
                
                // Add to sequence and update display
                placementSequence.push({
                    blockId: parseInt(blockId),
                    position: parseInt(targetPosition)
                });
                updateSequenceDisplay();
                
                // Update pieces count
                updatePiecesCount();
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            this.classList.add('dragover');
        }
        
        function handleDragLeave() {
            this.classList.remove('dragover');
        }
        
        function handleDragStart(e) {
            e.dataTransfer.setData('text/plain', this.dataset.position);
            this.classList.add('dragging');
        }
        
        function handleDragEnd() {
            this.classList.remove('dragging');
        }

        function showError(message) {
            const errorElement = document.getElementById('error-message');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            
            setTimeout(() => {
                errorElement.style.display = 'none';
            }, 3000);
        }

        // Initialize the grid with the uploaded image
        splitButton.addEventListener('click', function() {
            if (!imageUpload.files.length) {
                showError('Please upload an image first');
                return;
            }
            
            const file = imageUpload.files[0];
            const reader = new FileReader();
            
            // Check file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                showError('Image is too large. Please select an image under 5MB.');
                return;
            }
            
            // Check file type
            if (!file.type.match('image.*')) {
                showError('Please select a valid image file.');
                return;
            }
            
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Create the source grid (pieces to drag)
                    sourceGrid.innerHTML = '';
                    for (let i = 1; i <= 9; i++) {
                        const gridItem = document.createElement('div');
                        gridItem.className = 'grid-item';
                        gridItem.dataset.position = i;
                        gridItem.draggable = true;
                        
                        const pieceImg = document.createElement('img');
                        pieceImg.src = e.target.result;
                        
                        // Calculate position for the piece
                        const row = Math.floor((i - 1) / 3);
                        const col = (i - 1) % 3;
                        
                        // Set size and position to show just this piece
                        pieceImg.style.width = '300px'; // Assuming a 3x3 grid for a 300x300px image
                        pieceImg.style.height = '300px';
                        pieceImg.style.left = `-${col * 100}px`;
                        pieceImg.style.top = `-${row * 100}px`;
                        
                        gridItem.appendChild(pieceImg);
                        sourceGrid.appendChild(gridItem);
                        
                        // Add drag event listeners
                        gridItem.addEventListener('dragstart', handleDragStart);
                        gridItem.addEventListener('dragend', handleDragEnd);
                    }
                    
                    // Create the target grid (where pieces will be dropped)
                    targetGrid.innerHTML = '';
                    for (let i = 1; i <= 9; i++) {
                        const gridCell = document.createElement('div');
                        gridCell.className = 'grid-cell';
                        gridCell.dataset.index = i;
                        
                        // Add drop event listeners
                        gridCell.addEventListener('dragover', handleDragOver);
                        gridCell.addEventListener('dragleave', handleDragLeave);
                        gridCell.addEventListener('drop', handleDrop);
                        
                        targetGrid.appendChild(gridCell);
                    }
                    
                    // Show the grids and progress indicator
                    gridContainer.style.display = 'flex';
                    document.getElementById('pattern-progress').style.display = 'block';
                    patternSequenceDiv.style.display = 'none';
                    
                    // Reset sequence
                    placementSequence = [];
                };
                
                img.src = e.target.result;
            };
            
            reader.readAsDataURL(file);
        });

        // Handle pattern submission
        patternForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            // Validation check
            if (!imageUpload.files || !imageUpload.files[0]) {
                showError('Please upload an image before continuing');
                return;
            }
            
            if (placementSequence.length !== 9) {
                showError('Please place all 9 pieces before continuing');
                return;
            }
            
            // Show loading state
            submitButton.disabled = true;
            submitButton.innerHTML = 'Saving pattern...';
            
            try {
                // Get the pattern data
                const pattern = logPattern();
                
                // Create form data from the form
                const formData = new FormData(patternForm);
                
                // Add the pattern data to the form
                formData.set('pattern', JSON.stringify(pattern));
                
                // Log what we're sending
                console.log('Sending data to server...');
                console.log('- Image:', imageUpload.files[0].name, imageUpload.files[0].size + ' bytes');
                console.log('- Pattern sequence:', JSON.stringify(pattern.sequence));
                
                // Send the data to the server
                const response = await fetch('{% url "register_level_two" %}', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server response (error):', response.status, errorText);
                    throw new Error(`Server returned ${response.status}: ${errorText}`);
                }
                
                // Parse the JSON response
                const data = await response.json();
                console.log('Server response (success):', data);
                
                if (data.status === 'success') {
                    // Show success message
                    showSuccess(data.message);
                    
                    // Redirect to level three after a delay
                    setTimeout(() => {
                        window.location.href = data.redirect_url;
                    }, 1500);
                } else {
                    showError(data.message || 'Unknown error occurred');
                    // Reset button state
                    submitButton.disabled = false;
                    submitButton.innerHTML = 'Save Pattern';
                }
            } catch (error) {
                console.error('Error during form submission:', error);
                showError('Error saving pattern: ' + error.message);
                
                // Reset button state
                submitButton.disabled = false;
                submitButton.innerHTML = 'Save Pattern';
            }
        });
        
        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'alert alert-success mt-3';
            successDiv.textContent = message;
            
            // Insert before the error message
            const errorElement = document.getElementById('error-message');
            errorElement.parentNode.insertBefore(successDiv, errorElement);
            
            // Hide after a delay
            setTimeout(() => {
                successDiv.remove();
            }, 3000);
        }
    });
</script>
{% endblock %} 